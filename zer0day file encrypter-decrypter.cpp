/*

References:
https://en.wikipedia.org/wiki/Advanced_Encryption_Standard
https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_(CBC)
https://cryptography.fandom.com/wiki/Rijndael_S-box
https://cboard.cprogramming.com/c-programming/87805-[tutorial]-implementing-advanced-encryption-standard.html
https://www.youtube.com/watch?v=bERjYzLqAfw&list=PLKK11LigqitiRH57AbtyJyzsfbNfA8nb-&index=4
https://www.youtube.com/watch?v=5PHMbGr8eOA

*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <time.h>
#include <ctype.h>
#include <string.h>
#include <conio.h>
#include <stdio.h>
#include <dirent.h>
#include <windows.h>

void fileencryption(char *location, char *destination, unsigned char *key);
void filedecryption(char *location, char *destination, unsigned char *key);
void directoryencrypt(char *location, char *destination,unsigned char *key);
void directorydecrypt(char *location, char *destination,unsigned char *key);
void locationgenerator(char *location, char *destination, char *filenm, char *sourceloc, char *destloc, int operationMode);
void operationdeck(char *location, char *destination,unsigned char *key, int dirorfile, int option);
int sourcedirchecker(char *location);
int filechecker(char *location);

static const uint8_t sbox[256] = { // Rijndael substitution lookup table
  //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F
  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };
  
static const uint8_t rs_box[256] = { // inverse sbox
  0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };
  
static const uint8_t Rcon[8] = { //round constants that are necessary for aes256
  0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40 };
  
static const uint8_t mul2[256] = {  // Multiplication lookup tables for MixColumns step.
	0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
	0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
	0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
	0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
	0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
	0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
	0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
	0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
	0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
	0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
	0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
	0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
	0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
	0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
	0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
	0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5};

static const uint8_t mul3[256] = {
	0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
	0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
	0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
	0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
	0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
	0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
	0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
	0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
	0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
	0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
	0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
	0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
	0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
	0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
	0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
	0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a};

static const uint8_t mul9[256] = {
    0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
    0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
    0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
    0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
    0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
    0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
    0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
    0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,
    0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,
    0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
    0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
    0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
    0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
    0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,
    0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
    0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46};
    
static const uint8_t mul11[256] = {
    0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
    0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
    0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
    0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
    0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
    0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
    0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
    0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
    0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
    0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
    0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
    0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
    0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
    0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
    0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
    0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3};
    
static const uint8_t mul13[256] = {
    0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
    0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
    0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
    0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
    0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
    0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
    0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
    0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
    0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
    0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
    0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
    0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
    0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
    0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
    0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
    0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97};

static const uint8_t mul14[256] = {
    0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
    0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
    0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
    0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
    0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
    0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
    0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
    0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
    0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
    0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
    0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
    0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
    0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
    0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
    0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
    0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d};

unsigned char previousState[17];
unsigned char iv[17];
  
void cryptionloop(char* sourceLocation, char* destinationLocation, int operationMode, char* key);
int dirfilenumber(char*location);
void findfilename(char*location,char *filename,int number);
void fileLocationgenerator(char *location, char *filename, char *fileloc);
void filetester(char*fileloc);
int stringlenght(char *fileloc);
int stringlenght2(char *fileloc);
void cryptdatagenerator(unsigned char *text,char* location,int forpadd);
void ivadder(unsigned char *iv,unsigned char *fulltext,int forlenght);
void filewriter(unsigned char *text,char *dest, char *name,int forlenght);
void ivsub(unsigned char*text,unsigned char *iv,int forlenght);

void keyExpansionCore(unsigned char *word, int iteration){
	
	// rotate 8 bits to the left
	unsigned char temp = word[0];
	word[0]=word[1];
	word[1]=word[2];
	word[2]=word[3];
	word[3]=temp;
	
	// sbox substitution
	word[0]=sbox[word[0]];
	word[1]=sbox[word[1]];
	word[2]=sbox[word[2]];
	word[3]=sbox[word[3]];
	
	// XORing with round constant
	word[0]^=Rcon[iteration];
}

void KeyExpansion(unsigned char *expandedKey, unsigned char *key){
	
	//This step is beyond me, so just for this function, I modified an existing code, which can be found in references.
	
	/* current expanded keySize, in bytes */
    int currentSize = 0;
    int rconIteration = 1;
    int i;
    unsigned char t[4] = {0};   // temporary 4-byte variable
     
    /* set the 16,24,32 bytes of the expanded key to the input key */
    for (i = 0; i < 32; i++)
        expandedKey[i] = key[i];
    currentSize += 32;
     
    while (currentSize < 240)
    {
        /* assign the previous 4 bytes to the temporary value t */
        for (i = 0; i < 4; i++)
        {
            t[i] = expandedKey[(currentSize - 4) + i];
        }
         
        /* every 32 bytes we apply the core schedule to t and increment rconIteration afterwards */
        if(currentSize % 32 == 0)
        {
            keyExpansionCore(t, rconIteration++);
        }
 
        /* For 256-bit keys, we add an extra sbox to the calculation */
        if((currentSize % 32) == 16) {
            for(i = 0; i < 4; i++) 
                t[i] = sbox[t[i]];
        }
         
        /* We XOR t with the four-byte block 32 bytes before the new expanded key.
         * This becomes the next four bytes in the expanded key.
         */
        for(i = 0; i < 4; i++) {
            expandedKey[currentSize] = expandedKey[currentSize - 32] ^ t[i];
            currentSize++;
        }
    }
}

void AddRoundKey(unsigned char *state, unsigned char *roundKey){
	//XORing state with round key
	for(int i=0; i<16; i++){
		state[i] ^= roundKey[i];
	}
}

void SubBytes(unsigned char *state){ 
	//substitute bytes from rijndael s-box
	for(int i=0; i<16; i++){
		state[i]=sbox[state[i]];
	}
}

void ShiftRows(unsigned char *state){
	
	unsigned char temp[16];
	
	temp[0] = state[0];
	temp[1] = state[5];
	temp[2] = state[10];
	temp[3] = state[15];
	
	temp[4] = state[4];
	temp[5] = state[9];
	temp[6] = state[14];
	temp[7] = state[3];
	
	temp[8] = state[8];
	temp[9] = state[13];
	temp[10] = state[2];
	temp[11] = state[7];
	
	temp[12] = state[12];
	temp[13] = state[1];
	temp[14] = state[6];
	temp[15] = state[11];
	
	for(int i=0; i<16; i++){
		state[i]=temp[i];
	}
	
}

void MixColumns(unsigned char *state){
	
	/* 
		Multiply the state by the following matrix:
	   2 3 1 1
	   1 2 3 1
	   1 1 2 3
	   3 1 1 2
	*/	
	
	unsigned char tmp[16];
	
	tmp[0] = (unsigned char)(mul2[state[0]] ^ mul3[state[1]] ^ state[2] ^ state[3]);
	tmp[1] = (unsigned char)(state[0] ^ mul2[state[1]] ^ mul3[state[2]] ^ state[3]);
	tmp[2] = (unsigned char)(state[0] ^ state[1] ^ mul2[state[2]] ^ mul3[state[3]]);
	tmp[3] = (unsigned char)(mul3[state[0]] ^ state[1] ^ state[2] ^ mul2[state[3]]);

	tmp[4] = (unsigned char)(mul2[state[4]] ^ mul3[state[5]] ^ state[6] ^ state[7]);
	tmp[5] = (unsigned char)(state[4] ^ mul2[state[5]] ^ mul3[state[6]] ^ state[7]);
	tmp[6] = (unsigned char)(state[4] ^ state[5] ^ mul2[state[6]] ^ mul3[state[7]]);
	tmp[7] = (unsigned char)(mul3[state[4]] ^ state[5] ^ state[6] ^ mul2[state[7]]);

	tmp[8] = (unsigned char)(mul2[state[8]] ^ mul3[state[9]] ^ state[10] ^ state[11]);
	tmp[9] = (unsigned char)(state[8] ^ mul2[state[9]] ^ mul3[state[10]] ^ state[11]);
	tmp[10] = (unsigned char)(state[8] ^ state[9] ^ mul2[state[10]] ^ mul3[state[11]]);
	tmp[11] = (unsigned char)(mul3[state[8]] ^ state[9] ^ state[10] ^ mul2[state[11]]);

	tmp[12] = (unsigned char)(mul2[state[12]] ^ mul3[state[13]] ^ state[14] ^ state[15]);
	tmp[13] = (unsigned char)(state[12] ^ mul2[state[13]] ^ mul3[state[14]] ^ state[15]);
	tmp[14] = (unsigned char)(state[12] ^ state[13] ^ mul2[state[14]] ^ mul3[state[15]]);
	tmp[15] = (unsigned char)(mul3[state[12]] ^ state[13] ^ state[14] ^ mul2[state[15]]);
 
 	for(int i=0; i<16; i++){
 		state[i]=tmp[i];
	 }
	
}

void generateIV(unsigned char* iv){
	//generating initial vector
	srand(time(NULL));
	
	for(int i=0; i<16;i++)
		iv[i]=rand()%16;
	
}

void encrypt(unsigned char *textPortion, unsigned char *key){	// The actual encrypting function
	
	int numberOfRounds = 14-1;
	
	//copying the 16 byte text to state matrix
	unsigned char state[16];
	for (int i = 0; i < 16; i++)
        state[i] = textPortion[i];
        
    /*
	if(round == 0){	//generating initial vector iv
	
		generateIV(iv);
		for(int i=0; i<16; i++) //xoring plain text with iv
			state[i] ^= iv[i];
	}
	else{
		for(int i=0; i<16; i++) //xoring plain text with previous state
			state[i] ^= previousState[i];
	}
	*/
        
	unsigned char expandedKey[240]; //declaring expanded key array. This is where the newly generated keys are stored.
	
	KeyExpansion(expandedKey, key);	//Key expansion step of the aes
	
	AddRoundKey(state, expandedKey); //initial round
	
	//rounds
	for(int i=1;i<=numberOfRounds;i++){
	SubBytes(state); 
	ShiftRows(state);
	MixColumns(state);
	AddRoundKey(state, expandedKey + 16*i); //Every round uses different key. Because keys are 16 bytes length, I increment the pointer by 16 in each round.
	}
	
	//final round
	SubBytes(state);
	ShiftRows(state);
	AddRoundKey(state, expandedKey + 224);  
	
	for (int i = 0; i < 16; i++)	//copying the state to text
        textPortion[i] = state[i];
	
	memcpy(previousState, state, 16);
}

void InvSubBytes(unsigned char *state){
	//substitute bytes from the reverse s-box
	for(int i=0; i<16; i++){
		state[i]=rs_box[state[i]];
	}
}

void InvShiftRows(unsigned char *state){
	
	//shift to right
	
	/*
		 ____________		 	 ____________
		 
		|  0 4 8 12 |			|  0 4 8 12 |
		|  1 5 9 13 | 	-->		|  13 1 5 9 |
		| 2 6 10 14 |			| 10 14 2 6 |
		| 3 7 11 15 |			| 7 11 15 3 |
		____________			____________
	*/
	
	unsigned char temp[16];
	
	temp[0] = state[0];
	temp[1] = state[13];
	temp[2] = state[10];
	temp[3] = state[7];
	
	temp[4] = state[4];
	temp[5] = state[1];
	temp[6] = state[14];
	temp[7] = state[11];
	
	temp[8] = state[8];
	temp[9] = state[5];
	temp[10] = state[2];
	temp[11] = state[15];
	
	temp[12] = state[12];
	temp[13] = state[9];
	temp[14] = state[6];
	temp[15] = state[3];
	
	for(int i=0; i<16; i++){
		state[i]=temp[i];
	}
	
}

void InvMixColumns(unsigned char *state){
	
	/* Multiply state by the matrix:
	0E 0B 0D 09
	09 0E 0B 0D
	0D 09 0E 0B 
	0B 0D 09 0E
	*/
	
	unsigned char tmp[16];
	
	tmp[0] = (unsigned char)(mul14[state[0]] ^ mul11[state[1]] ^ mul13[state[2]]^ mul9[state[3]]);
	tmp[1] = (unsigned char)(mul9[state[0]] ^ mul14[state[1]] ^ mul11[state[2]] ^ mul13[state[3]]);
	tmp[2] = (unsigned char)(mul13[state[0]] ^ mul9[state[1]] ^ mul14[state[2]] ^ mul11[state[3]]);
	tmp[3] = (unsigned char)(mul11[state[0]] ^ mul13[state[1]] ^ mul9[state[2]] ^ mul14[state[3]]);

	tmp[4] = (unsigned char)(mul14[state[4]] ^ mul11[state[5]] ^ mul13[state[6]]^ mul9[state[7]]);
	tmp[5] = (unsigned char)(mul9[state[4]] ^ mul14[state[5]] ^ mul11[state[6]] ^ mul13[state[7]]);
	tmp[6] = (unsigned char)(mul13[state[4]] ^ mul9[state[5]] ^ mul14[state[6]] ^ mul11[state[7]]);
	tmp[7] = (unsigned char)(mul11[state[4]] ^ mul13[state[5]] ^ mul9[state[6]] ^ mul14[state[7]]);
	
	tmp[8] = (unsigned char)(mul14[state[8]] ^ mul11[state[9]] ^ mul13[state[10]]^ mul9[state[11]]);
	tmp[9] = (unsigned char)(mul9[state[8]] ^ mul14[state[9]] ^ mul11[state[10]] ^ mul13[state[11]]);
	tmp[10] = (unsigned char)(mul13[state[8]] ^ mul9[state[9]] ^ mul14[state[10]] ^ mul11[state[11]]);
	tmp[11] = (unsigned char)(mul11[state[8]] ^ mul13[state[9]] ^ mul9[state[10]] ^ mul14[state[11]]);

	tmp[12] = (unsigned char)(mul14[state[12]] ^ mul11[state[13]] ^ mul13[state[14]]^ mul9[state[15]]);
	tmp[13] = (unsigned char)(mul9[state[12]] ^ mul14[state[13]] ^ mul11[state[14]] ^ mul13[state[15]]);
	tmp[14] = (unsigned char)(mul13[state[12]] ^ mul9[state[13]] ^ mul14[state[14]] ^ mul11[state[15]]);
	tmp[15] = (unsigned char)(mul11[state[12]] ^ mul13[state[13]] ^ mul9[state[14]] ^ mul14[state[15]]);
 
 	for(int i=0; i<16; i++){
 		state[i]=tmp[i];
	 }
}

void decrypt(unsigned char* encryptedText, unsigned char* key){	// The actual decrypting function
	
	int numberOfRounds = 13;
	
	unsigned char state[16];
	for (int i = 0; i < 16; i++){
        state[i] = encryptedText[i];
	}
        
	unsigned char expandedKey[240];
	
	KeyExpansion(expandedKey, key);
	
	AddRoundKey(state, expandedKey + 224); 
	InvShiftRows(state);
	InvSubBytes(state);
	
	//rounds
	for(int i=13;i>=1;i--){
		AddRoundKey(state, expandedKey + (16*i)); //Here, the steps proceed in the reverse order of encrypting. AddRoundKey remains the same.
		InvMixColumns(state);						// But for other steps, inversed version of the functions are needed.
		InvShiftRows(state);
		InvSubBytes(state); 
	}
	
	//final round
	AddRoundKey(state, expandedKey);
	
	//lastly, combine with iv
/*	for(int i=0; i<16; i++) 
		state[i] ^= iv[i];
*/	
	for (int i = 0; i < 16; i++)
        encryptedText[i] = state[i];
	
}

/*int keyChecker(char* key){	//checks if the input key is in valid format. 
	
	for(int i=0;i<32;i++){
		if( isxdigit(key[i]) == 0)
			return 0;	
	}
	
	if(strlen((char*)key)!=32)
		return 0;
		
	return 1;
}*/

int  directoryChecker(char *location){
	DIR* directory;
	directory=opendir(location);
	if(directory==NULL){
		return 0;
	}
	else{
		return 1;
	}
}

void print_logo(){
	
	printf("                ___      _             \n");
	printf("  _______ _ __ / _ \\  __| | __ _ _   _ \n");
	printf(" |_  / _ \\ '__| | | |/ _` |/ _` | | | |\n");
	printf("  / /  __/ |  | |_| | (_| | (_| | |_| |\n");
	printf(" /___\\___|_|   \\___/ \\__,_|\\__,_|\\__, |\n");
	printf("                                 |___/ \n\n");

}

void gotoxy(short x, short y) {
	COORD pos = {x, y};
	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos);
}

void progressBar(int size, int rowcounter){
	//print_logo();
	float percentage = (rowcounter*1600/size);
	
	if((rowcounter+1)==(size/16))
		percentage = 100;
	
	gotoxy(45,8);
	printf("status: %%%.f complete.\n", percentage);
	
	gotoxy(30+(percentage/2),10);
	for(int i=(percentage/2); i<50; i++){
		printf("%c", 177);
	}
	
	gotoxy(30,10);
	for(int i=0; i<(percentage/2); i++){
		printf("%c", 178);
	}
	gotoxy(30,12);
}

double startTime, endTime;

int main(){
	
	print_logo();
	
	unsigned char key[33] = ""; //as plaintext
	
	int dirorfile;
	int operationMode;
	char sourceLocation[256];
	char destination[256];
	
	printf("What do you want to encrypt or decrypt? Enter 1 for file, 2 for directory: ");
	while (1) {
    	scanf("%d", &dirorfile);
    	if (dirorfile == 1 || dirorfile == 2) {
        break;
    	}
    	printf("\nEnter a valid option: ");
	}
	
	if(dirorfile==1){
		printf("\nEnter the file location: ");
		while(1){   //Asking the user for input until they give a valid response
    		scanf(" %s",sourceLocation);
    		if(filechecker(sourceLocation) == 1 ) break;
    		printf("\nFile not found. Enter a valid directory: ");
		}
		printf("\nEnter the full path to store decrypted data (please don't forget to add .txt): ");
		scanf(" %s",destination);	//this does not check if the input is valid, because testing if it was a directory is HARD
	}
	
	else if(dirorfile==2){
			printf("\nEnter the directory location: ");
		while(1){   //Asking the user for input until they give a valid response
			scanf(" %s",sourceLocation);
    		if(sourcedirchecker(sourceLocation) == 1 ) break;
    		printf("\nDirectory not found. Enter a valid directory: ");
		}
		printf("\nEnter the directory to store decrypted files: ");
		while(1){   //Asking the user for input until they give a valid response
    	scanf(" %s",destination);
    	if(sourcedirchecker(destination) == 1 ) break;
    	printf("Directory not found. Enter a valid directory:");
		}
	}
	
	printf("\nEnter operation mode: 1 for encrypt / 2 for decrypt: ");
	while(1){   //Asking the user for input until they give a valid response
    	scanf(" %d", &operationMode);
    	if(operationMode == 1 || operationMode == 2) break;
    	printf("\nEnter a valid operation mode, 1 or 2.\n");
	}
	
	printf("\nEnter your 256-bit plain text key: ");
	while(1){   //Asking the user for input until they give a valid response
		scanf("%s", &key);
    	if( (sizeof(key)/sizeof(unsigned char) ) == 33 ) break;
    	printf("\nInvalid key. Enter a valid key: ");
	}
	
	startTime = clock();
	operationdeck(sourceLocation,destination,key,dirorfile,operationMode);
	
	printf("\nTime elapsed: %.2f ms\n", endTime - startTime);
	
	return 0;
}

void operationdeck(char *location, char *destination, unsigned char *key, int dirorfile, int option){
	system("cls");
	if(dirorfile==1){//If choosen option crypt file this function works.
		if(option==1){
			fileencryption(location,destination,key);	
		}
		else if(option==2){
			filedecryption(location,destination,key);
		}
	}
	
	else if(dirorfile==2){//If choosen option crypt directory this function works.
		if(option==1){
			directoryencrypt(location,destination,key);
		}
		else if(option==2){
			directorydecrypt(location,destination,key);
		}
	}
}

int sourcedirchecker(char *location){
	
	DIR* dirptr;
	dirptr=opendir(location);
	
	if(dirptr==NULL){
		return 0;
	}
	else{
		return 1;
	}
}

int filechecker(char *location){
	
	FILE *fileptr;
	fileptr=fopen(location,"r");
	
	if(fileptr==NULL){
		return 0;
	}
	else{
		return 1;
	}
}

//Reads filenames in directory to encrypt files.
void directoryencrypt(char *location, char *destination,unsigned char *key){
	
	struct dirent *fnameptr;
	
	char fullsourcelocation[512];
	char fulldestlocation[512];
	
	DIR *locptr,*destptr;
	
	locptr=opendir(location);
	destptr=opendir(destination);
	
	int i=0;
	while((fnameptr=readdir(locptr))!= NULL){
		if(i<2){
			++i;
		}
		else{
		locationgenerator(location,destination,fnameptr->d_name,fullsourcelocation,fulldestlocation,1);
		
		fileencryption(fullsourcelocation,fulldestlocation,key);	
		}
	}
	
}

//encrypt files.
void fileencryption(char *location, char *destination, unsigned char *key){
	
	int round=0;
	//unsigned char iv[16];
	
	FILE *loc,*dest;
	
	loc=fopen(location,"r");
	dest=fopen(destination,"w");
	
	if(loc==NULL){
		printf("CAN NOT OPEN THIS FILE: %s\n",location);
	}
	
	unsigned char padd='*';
	
	int padding;   
 	fseek(loc, 0, SEEK_END);   
 	int datalenght = ftell(loc); 
 	rewind(loc);
 	
 	padding=16-(datalenght%16);
	int size=datalenght+padding;
	
 	unsigned char textToEncrypt[size+17];
	unsigned char textPortion[17];

 	fread(&textToEncrypt,sizeof(unsigned char),size,loc);
	
	for(int i=0;i<padding;i++){
		textToEncrypt[datalenght+i]=padd;	
	}
	
	int rowcounter=0;
	for(int i=1;i<=size/16;i++){
		for(int j=0 ; j<16 ; j++){
			textPortion[j]=textToEncrypt[j+(16*rowcounter)];
		}
			textPortion[16]='\0';
			encrypt(textPortion,key);
		round++;
		for(int j=0 ; j<16 ; j++){
			textToEncrypt[j+(16*rowcounter)]=textPortion[j];
		}
		rowcounter++;
		progressBar(size,rowcounter);
	}
	/*
	for(int i=1;i<padding;i++){
		textToEncrypt[datalenght+i]='\0';
	}*/
	/*
	for (int i=0;i<16;i++){
		textToEncrypt[size+i]=iv[i];
	}
	*/
	rowcounter=0;
	round=0;
	
	
	fwrite(textToEncrypt,sizeof(unsigned char),size,dest);
	rewind (loc);
	fclose(dest);
	fclose(loc);
	endTime = clock();

}

//Reads directory file names sends file names to locationgenerator and sends location to decryption.
void directorydecrypt(char *location, char *destination,unsigned char *key){
	
	struct dirent *fnameptr;
	
	char fullsourcelocation[512];
	char fulldestlocation[512];
	
	DIR *locptr,*destptr;
	
	locptr=opendir(location);
	destptr=opendir(destination);
	
	int i=0;
	while((fnameptr=readdir(locptr))!= NULL){//reads filenames in directory.
		if(i<2){//Firs two filenames are ".", ".." as defoult.To skip this part i used if.
			++i;
		}
		else{
		locationgenerator(location,destination,fnameptr->d_name,fullsourcelocation,fulldestlocation,2);
		
		filedecryption(fullsourcelocation,fulldestlocation,key);	
		}
	}
	
}

//Decrypt files.
void filedecryption(char *location, char *destination, unsigned char *key){
	
	//unsigned char iv[16];	
	
	FILE *loc,*dest;
	
	loc=fopen(location,"r");
	dest=fopen(destination,"w");
	
	if(loc==NULL){
		printf("CAN NOT OPEN THIS FILE: %s\n",location);
	}
	unsigned char padd='*';
	int datalength=0;
	int padding;   
 	fseek(loc, 0, SEEK_END);   
 	datalength = ftell(loc); 
 	rewind (loc);
	padding=16-(datalength%16);
	int size=datalength+padding;
	
	unsigned char textToDecrypt[size+1];
	unsigned char textPortion[size+1];
	
	fread(&textToDecrypt,sizeof(unsigned char),size,loc);
	
	/*
	for(int i=15;i>=0;i--){//reading iv
		iv[15-i]=ctext[datalenght-i-1];
	}
	*/
	
	for(int i=0;i<padding;i++){//Adds padding to files.
		textToDecrypt[datalength+i]=padd;	
	}
	
	int rowcounter=0;
	for(int i=1;i<=size/16;i++){
		
		for(int j=0 ; j<16 ; j++){
			textPortion[j]=textToDecrypt[j+(16*rowcounter)];
		}
		
		decrypt(textPortion,key);
		
		for(int j=0 ; j<16 ; j++){
			textToDecrypt[j+(16*rowcounter)]=textPortion[j];
		}
		rowcounter++;
		progressBar(size,rowcounter);
	}
	rowcounter=0;
	//size=size-padding;
	fwrite(textToDecrypt,sizeof(unsigned char),datalength,dest);//writes decrypted data to files.
	fclose(dest);
	fclose(loc);
	endTime = clock();
}

//creates locations suitable to read for "fopen" with directory names.
void locationgenerator(char *location, char *destination, char *filenm, char *source, char *dest, int operationMode){
	
	char space='\\';
	char encrypted_extension[]="encrypted_";
	char decrypted_extension[]="decrypted_";
	
	strcpy(source,location);
	strncat(source,&space,1);
	strncat(source,filenm,256);
	
	strcpy(dest,destination);
	strncat(dest,&space,1);
	
	if(operationMode == 1)
		strncat(dest,encrypted_extension,10);
	else
		strncat(dest,decrypted_extension,10);
	
	strncat(dest,filenm,256);
}
